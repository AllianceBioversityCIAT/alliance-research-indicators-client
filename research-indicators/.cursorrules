# Project Technology Stack and Best Practices

## Angular Version and Features

Tiene que habalrme en espaÃ±ol

- Using Angular 18
- Using PrimeNG 18
- Using Signals for state management
- Using modern Angular features like standalone components and inject function

## Best Practices

1. Always search for the most recent documentation and solutions
   - Prefer Angular.io official documentation
   - Check release dates of blog posts and solutions
   - Prefer solutions that use modern Angular features (signals, inject, etc.)
   - Avoid outdated patterns (like NgZone for signal updates)

## orders

- cuando te diga que migres de clases y scss, vas a borrar el archivo scss, si necesitas algo que no s epeude hacer cn tialwin lo poner el el .ts y siempre debes respetar las reglas del archivo responsive-size.scss, este no se puede cambiar, lo demas si,

## Common Pitfalls to Avoid

1. Height Detection in Components

   - Use ElementRef with querySelector for direct DOM access when needed
   - ResizeObserver works directly with signals, no need for NgZone
   - Example:

     ```typescript
     elementRef = inject(ElementRef);

     ngAfterViewInit(): void {
       const element = this.elementRef.nativeElement.querySelector('#myElement');
       if (element) {
         this.resizeObserver = new ResizeObserver(entries => {
           for (const entry of entries) {
             this.mySignal.set(entry.contentRect.height);
           }
         });
         this.resizeObserver.observe(element);
       }
     }
     ```

2. State Management

   - Prefer signals over BehaviorSubject/Observable for simple state
   - Use computed() for derived state
   - Use effect() for side effects

3. Component Architecture
   - Use standalone components by default
   - Use inject() function instead of constructor injection
   - Use OnPush change detection strategy when possible

## Testing Guidelines

1. Unit Tests (.spec.ts files)

   - Only fix existing tests, do not add new ones unless specifically requested
   - Follow this process when fixing tests:
     1. Run all tests first: `npm run test` to identify failing tests
     2. Run individual failing tests to isolate issues
     3. Fix tests considering the full context (signals, inject, etc.)
     4. Run individual tests again to verify fixes
     5. Run complete test suite to ensure no regressions
   - Consider the following when fixing tests:
     - Understand signal behavior in tests
     - Use TestBed.inject() for dependency injection
     - Mock services and dependencies appropriately
     - Respect component lifecycle hooks
     - Handle async operations properly
   - Provide confirmation message when all tests are passing
   - cuando diga "corrige pruebas unitarias" debes correr npm run test y valdiar las que tienen error, una vez se corran las pruebas, solo corres la o las que fallan
   - cuando diga "mejora branches" te voy a dar un archivo .spec.ts y debes mejorar el coverage en branches, luego corres la prueba con el archivo para valdiar si aumento o no
   - cuando diga "mejora lines" te voy a dar un archivo .spec.ts y debes mejorar el coverage en lines, luego corres la prueba con el archivo para valdiar si aumento o no
   - cuando diga "mejora functions" te voy a dar un archivo .spec.ts y debes mejorar el coverage en functions, luego corres la prueba con el archivo para valdiar si aumento o no
   - todo lo que tenga que ver con pruebas, claramente con jest, debes ser muy logico con lo que se va a hacer y tener contexto de las demas preubas para entender como solucionar ya errores o problemas resueltos

2. Angular 18 + Jest Specific Testing Rules:

   **Signal Testing:**

   - Use `signal()` for mock signals, not jest.fn()
   - WritableSignal mocks: `mockSignal = { set: jest.fn(), update: jest.fn() } as any`
   - For effects testing: always call `TestBed.flushEffects()` after signal changes
   - Mock computed signals as regular functions that return values

   **Service Mocking:**

   - Services with inject(): Mock in providers array of TestBed
   - ServiceLocatorService pattern: Mock getService() to return your mocked service
   - Services returning signals: Mock with resolved promises returning signal instances
   - Always initialize mocks in beforeEach with realistic return values

   **Component Setup:**

   - Standalone components: Import directly in TestBed.imports array
   - Set all @Input() properties before calling ngOnInit()
   - Use NoopAnimationsModule for PrimeNG components
   - Mock all required services in providers array

   **Async Testing:**

   - Use async/await consistently, not .then()
   - Test loading states: set signal before call, verify during, verify after
   - Mock async service methods with `jest.fn().mockResolvedValue()`
   - Always await component async methods in tests

   **Coverage Optimization:**

   - Focus on core functionality, not implementation details
   - Comment out problematic tests that don't add real value
   - Aim for 95%+ statements coverage on important components
   - Test all public methods and computed properties
   - Mock external dependencies completely

   **Jest Configuration Awareness:**

   - Check testPathIgnorePatterns in jest.config.ts
   - Some directories might be ignored (like custom-fields)
   - Temporarily modify jest.config.ts if needed for testing specific files
   - Always revert jest.config.ts changes after testing

   **Common Error Patterns to Avoid:**

   - Don't mix jasmine and jest syntax
   - Don't access private methods in tests
   - Don't test Angular internal behavior
   - Don't create overly complex effect tests
   - Always verify mocks are called with correct parameters

3. Error Resolution Strategy:
   - Run `npm test` first to see all failing tests
   - Focus on one failing test at a time
   - Check if test dependencies are properly mocked
   - Verify component inputs are set before ngOnInit
   - Use `fixture.detectChanges()` after component setup
   - For signal errors: ensure proper mock setup with actual signal instances

## Token Optimization Rules

1. Response Format

   - Use "Success" for successful operations
   - Use "Error: [specific error]" for failures
   - Avoid decorative language or pleasantries
   - Skip redundant confirmations

2. Code Generation

   - Generate minimal viable code
   - Skip optional comments
   - Use shorthand syntax when possible
   - Avoid redundant type declarations when inferrable

3. Error Handling

   - Report only relevant error details
   - Skip stack traces unless requested
   - Use concise error messages

4. Documentation

   - Keep explanations brief and technical
   - Use bullet points over paragraphs
   - Skip obvious information
   - Focus on key technical details

5. Testing
   - Report only failing tests
   - Use minimal test descriptions
   - Skip passing test details
   - Report only changed values
